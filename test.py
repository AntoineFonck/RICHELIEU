#!/usr/bin/env python3
import pyasn1.codec.der.encoder
import pyasn1.type.univ
import base64
import sys

sys.setrecursionlimit(1500)

e = 0x010001
n = 837849563862443268467145186974119695264713699736869090645354954749227901572347301978135797019317859500555501198030540582269024532041297110543579716921121054608494680063992435808708593796476251796064060074170458193997424535149535571009862661106986816844991748325991752241516736019840401840150280563780565210071876568736454876944081872530701199426927496904961840225828224638335830986649773182889291953429581550269688392460126500500241969200245489815778699333733762961281550873031692933566002822719129034336264975002130651771127313980758562909726233111335221426610990708111420561543408517386750898610535272480495075060087676747037430993946235792405851007090987857400336566798760095401096997696558611588264303087788673650321049503980655866936279251406742641888332665054505305697841899685165810087938256696223326430000379461379116517951965921710056451210314300437093481577578273495492184643002539393573651797054497188546381723478952017972346925020598375000908655964982541016719356586602781209943943317644547996232516630476025321795055805235006790200867328602560320883328523659710885314500874028671969578391146701739515500370268679301080577468316159102141953941314919039404470348112690214065442074200255579004452618002777227561755664967507
p = 0x00fb40dc44ba03d15342f75908e0f9300596644ade94685e08e28c9ab1640c2f62c29ab9a239824b9ebeeb76ae6d8721a35e9ed98d7e57383e590934a578cdf72e895d5c3752eafdf631ccbad2d960e4451d6776d21f129c9dc9b1904551edd2fbddb674b499fbb10ad9b7c2be8ba407220a8e3a36ff6dc11d6393afcb4ec0479f65bfdfe3f05f1e98614574ec36a7a5b1f18d3d976b5a82490900080d9dc274574e30a139682f22347113aa3bf2204f8e10ebd4d09bb58cc2535f9d71130c0f21b66e133940d3a6b1eb74addd0a291481b190ade053f089c800fedcad5659fc281dc0cf5e08c0543324a352bbf3251043c373b8404ffc6b6b77bd5f2224eb7f15
q = n // p
phi = (p -1)*(q-1)

def egcd(a, b):
  if a == 0:
    return (b, 0, 1)
  else:
    g, y, x = egcd(b % a, a)
    return (g, x - (b // a) * y, y)
 
def modinv(a, m):
  gcd, x, y = egcd(a, m)
  if gcd != 1:
    return None  # modular inverse does not exist
  else:
    return x % m

d = modinv(e,phi)

def pempriv(n, e, d, p, q, dP, dQ, qInv):
  template = '-----BEGIN RSA PRIVATE KEY-----\n{}-----END RSA PRIVATE KEY-----\n'
  seq = pyasn1.type.univ.Sequence()
  for x in [0, n, e, d, p, q, dP, dQ, qInv]:
    seq.setComponentByPosition(len(seq), pyasn1.type.univ.Integer(x))
  der = pyasn1.codec.der.encoder.encode(seq)
  return template.format(base64.encodestring(der).decode('ascii'))

dp = modinv(e,(p-1))
dq = modinv(e,(q-1))
#qi = pow(q, p - 2, p)
qi = modinv(q,p)

key = pempriv(n, e, d, p, q, dp, dq, qi)

f = open("DOESTHISWORK.key","w")
f.write(key)
f.close()
